###### 十月一日\&十月二日
&emsp;&emsp;完成返回hello world数据的服务器，大体了解nginx的工作方式和server规则和location规则

'''python

class Server(object):

    def __init__(self, port):
        # 创建套接字
        self.tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # 绑定本地ip、端口
        self.tcp_server_socket.bind(("", port))

        # listen变为被动/监听
        self.tcp_server_socket.listen(128)

    def service_client(self, new_socket):
        """为客户端返回数据"""
        # 1.接收客户端发来的请求，即http请求
        # GET / HTTP/1.1
        # ......
        request = new_socket.recv(1024).decode("gbk")
        # print(request)
        request_lines = request.splitlines()
        print("")
        print(">"*20)
        print(request_lines)

        # GET /index.html HTTP/1.1
        file_name = ""
        ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
        if ret:
            file_name = ret.group(1)
            print("*"*50, file_name)
            if file_name == "/":
                file_name = "/index.html"

        # 2.返回http格式的数据给客户端
        # 如果请求的是ping
            if file_name == "/ping":
                response = "HTTP/1.1 200 OK\r\n"
                response += "\r\n"
                response += "Hello World"
                new_socket.send(response.encode("utf-8"))
            else:
                try:
                    f = open(file_name, "rb")
                except:
                    response = "HTTP/1.1 404 NOT FOUND\r\n"
                    response += "\r\n"
                    response += "-------file not found-------"
                    new_socket.send(response.encode("utf-8"))
                else:
                    html_content = f.read()
                    f.close()
                    # 2.1.1 准备发送给浏览器的数据-----header
                    response = "HTTP/1.1 200 OK\r\n"
                    response += "\r\n"

                    # 2.1.2 准备发送给浏览器的数据-----body
                    # response += "hello"

                    # 将response header发送给浏览器
                    new_socket.send(response.encode("utf-8"))
                    # 将response body发送给浏览器
                    new_socket.send(html_content)

        # 关闭套接字
        new_socket.close()

    def run_forever(self):
        """用来完成整体控制"""
        while True:
            # accept等待接受链接(并接收返回的新生成的套接字和客户端地址)
            new_socket, client_addr = self.tcp_server_socket.accept()

            # 开始为该客户端服务
            # 为客户端提供服务
            p = multiprocessing.Process(target=self.service_client, args=(new_socket,))
            p.start()

            new_socket.close()

        # 关闭监听套接字
        self.tcp_server_socket.close()
'''
###### 十月三日&十月四日
&emsp;&emsp;解析了配置文件的server语句块和location语句块。。。还在迷茫搞出来怎么结合使用。。
'''python
class Nginx(object):

    def __init__(self, conf_path):
        self.conf_path = conf_path
        self.serverBlock = list()  # 保存解析后端每个server块
        self.servers = list()
        self.parse_server_block()

    def parse_server_block(self):
        """解析server语句块"""
        flag = False
        serverblock = ''
        num_of_quote = 0

        with open(self.conf_path, 'r', encoding="utf-8") as fp:
            for line in fp.readlines():
                x = line.replace(' ', '')
                if x.startswith('server{'):
                    num_of_quote += 1
                    flag = True
                    serverblock += line
                    continue
                # 发现{，计数加1.发现}，计数减1，直到计数为0
                if flag and '{' in line:
                    num_of_quote += 1

                if flag and num_of_quote != 0:
                    serverblock += line

                if flag and '}' in line:
                    num_of_quote -= 1

                if flag and num_of_quote == 0:
                    self.serverBlock.append(serverblock)
                    flag = False
                    serverblock = ''
                    num_of_quote = 0

        for singleServer in self.serverBlock:
            port = re.findall(r'listen\s*((?:\d|\s)*)[^;]*;', singleServer)[0]  # port

            r = re.findall(r'server_name\s+([^;]*);', singleServer)  # server_name

            # 可能存在没有server_name的情况
            if len(r) > 0:
                servername = r[0]
            else:
                continue

            # location
            locations = re.findall(r'location\s*[\^~\*=]*\s*([^{ ]*)\s*\{[^}]*proxy_pass\s+https?://([^;/]*)[^;]*;', singleServer)
            locations += re.findall(r'location\s*[\^~\*=]*\s*([^{ ]*)\s*\{[^}]*root\s+([^;]*)[^;]*;', singleServer)
            locations += re.findall(r'location\s*[\^~\*=]*\s*([^{ ]*)\s*\{[^}]*index\s+([^;]*)[^;]*;', singleServer)

            backend_list = list()
            backend_ip = ''

            # 可能存在多个location
            if len(locations) > 0:
                for location in locations:
                    backend_path = location[0]
                    poolname = location[1]
                    backend_ip = poolname

                    backend_list.append({"backend_path": backend_path, "backend_ip": backend_ip})

            server = {
                        'port': port,
                        'server_name': servername,
                        'backend': backend_list
                     }

            self.servers.append(server)
'''
