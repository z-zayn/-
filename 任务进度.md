###### 十月一日\&十月二日
&emsp;&emsp;完成返回hello world数据的服务器，大体了解nginx的工作方式和server规则和location规则

'''python

class Server(object):

def __init__(self, port):

    # 创建套接字
    self.tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # 绑定本地ip、端口
    self.tcp_server_socket.bind(("", port))

    # listen变为被动/监听
    self.tcp_server_socket.listen(128)

def service_client(self, new_socket):

    """为客户端返回数据"""
    # 1.接收客户端发来的请求，即http请求
    # GET / HTTP/1.1
    # ......
    request = new_socket.recv(1024).decode("gbk")
    # print(request)
    request_lines = request.splitlines()
    print("")
    print(">"*20)
    print(request_lines)

    # GET /index.html HTTP/1.1
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)
        print("*"*50, file_name)
        if file_name == "/":
            file_name = "/index.html"

    # 2.返回http格式的数据给客户端
    # 如果请求的是ping
        if file_name == "/ping":
            response = "HTTP/1.1 200 OK\r\n"
            response += "\r\n"
            response += "Hello World"
            new_socket.send(response.encode("utf-8"))
        else:
            try:
                f = open(file_name, "rb")
            except:
                response = "HTTP/1.1 404 NOT FOUND\r\n"
                response += "\r\n"
                response += "-------file not found-------"
                new_socket.send(response.encode("utf-8"))
            else:
                html_content = f.read()
                f.close()
                # 2.1.1 准备发送给浏览器的数据-----header
                response = "HTTP/1.1 200 OK\r\n"
                response += "\r\n"

                # 2.1.2 准备发送给浏览器的数据-----body
                # response += "hello"

                # 将response header发送给浏览器
                new_socket.send(response.encode("utf-8"))
                # 将response body发送给浏览器
                new_socket.send(html_content)

    # 关闭套接字
    new_socket.close()

def run_forever(self):

    """用来完成整体控制"""

    while True:
        # accept等待接受链接(并接收返回的新生成的套接字和客户端地址)
        new_socket, client_addr = self.tcp_server_socket.accept()

        # 开始为该客户端服务
        # 为客户端提供服务
        p = multiprocessing.Process(target=self.service_client, args=(new_socket,))
        p.start()

        new_socket.close()

    # 关闭监听套接字
    self.tcp_server_socket.close()
'''
